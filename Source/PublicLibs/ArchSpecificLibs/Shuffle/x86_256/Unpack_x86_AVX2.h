/* Unpack_x86_AVX2.h
 * 
 * Author           : Alexander J. Yee
 * Date Created     : 08/30/2015
 * Last Modified    : 08/30/2015
 * 
 */

#pragma once
#ifndef ymp_Unpack_x86_AVX2_H
#define ymp_Unpack_x86_AVX2_H
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#include <immintrin.h>
#include "PublicLibs/CompilerSettings.h"
#include "PublicLibs/ArchSpecificLibs/x86_AVX2.h"
namespace ymp{
namespace SIMD{
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
YM_FORCE_INLINE __m256i load2_m128i_AVX(const void* L, const void* H){
    return _mm256_loadu2_m128i((const __m128i*)(H), (const __m128i*)(L));
}
YM_FORCE_INLINE void store2_m128i_AVX(void* L, void* H, __m256i x){
    _mm256_storeu2_m128i((__m128i*)(H), (__m128i*)(L), x);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Double Precision
template <int bits> YM_FORCE_INLINE __m256i unpacklo_AVX2(__m256i a, __m256i b);
template <int bits> YM_FORCE_INLINE __m256i unpackhi_AVX2(__m256i a, __m256i b);
////////////////////////////////////////////////////////////////////////////////
template <> YM_FORCE_INLINE __m256i unpacklo_AVX2<32>(__m256i a, __m256i b){
    b = _mm256_shuffle_epi32(b, 177);
    return _mm256_blend_epi16(a, b, 0xcc);
}
template <> YM_FORCE_INLINE __m256i unpackhi_AVX2<32>(__m256i a, __m256i b){
    a = _mm256_shuffle_epi32(a, 177);
    return _mm256_blend_epi16(a, b, 0xcc);
}
////////////////////////////////////////////////////////////////////////////////
template <> YM_FORCE_INLINE __m256i unpacklo_AVX2<64>(__m256i a, __m256i b){
    return _mm256_unpacklo_epi64(a, b);
}
template <> YM_FORCE_INLINE __m256i unpackhi_AVX2<64>(__m256i a, __m256i b){
    return _mm256_unpackhi_epi64(a, b);
}
////////////////////////////////////////////////////////////////////////////////
template <> YM_FORCE_INLINE __m256i unpacklo_AVX2<128>(__m256i a, __m256i b){
    return _mm256_permute2x128_si256(a, b, 32);
}
template <> YM_FORCE_INLINE __m256i unpackhi_AVX2<128>(__m256i a, __m256i b){
    return _mm256_permute2x128_si256(a, b, 49);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
}
}
#endif
