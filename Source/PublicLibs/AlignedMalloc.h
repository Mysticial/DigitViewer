/* AlignedMalloc.h
 * 
 * Author           : Alexander J. Yee
 * Date Created     : 01/25/2015
 * Last Modified    : 01/25/2015
 * 
 */

#pragma once
#ifndef _ymp_AlignedMalloc_H
#define _ymp_AlignedMalloc_H
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Dependencies
#include <stdlib.h>
#include <memory>
#include "Types.h"
namespace ymp{
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
const upL_t DEFAULT_ALIGNMENT = 64;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
inline void* AlignedMalloc(upL_t bytes, upL_t align = DEFAULT_ALIGNMENT){
    if (align < sizeof(upL_t))
        align = sizeof(upL_t);

    void *ptr = malloc((size_t)(bytes + align + sizeof(upL_t)));
    if (ptr == nullptr){
        return nullptr;
    }

    upL_t *ret = (upL_t*)((((upL_t)ptr + sizeof(upL_t)) & ~(upL_t)(align - 1)) + align);

    ret[-1] = (upL_t)ptr;

    return ret;
}
inline void AlignedFree(void *ptr){
    if (ptr == nullptr)
        return;

    ptr = (void*)(((upL_t*)ptr)[-1]);

    free(ptr);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename wtype = void>
struct SmartPointer{
    typedef std::unique_ptr<wtype, SmartPointer> type;
    void operator()(void* ptr) const{
        AlignedFree(ptr);
    }
    static type malloc_uptr(upL_t size, upL_t align = 0){
        return type((wtype*)AlignedMalloc(size * sizeof(wtype), align));
    }
};
template <>
struct SmartPointer<void>{
    typedef std::unique_ptr<void, SmartPointer> type;
    void operator()(void* ptr) const{
        AlignedFree(ptr);
    }
    static type malloc_uptr(upL_t size, upL_t align = 0){
        return type((void*)AlignedMalloc(size, align));
    }
};
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
}
#endif
