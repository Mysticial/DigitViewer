/* AlignedSmartPointers.h
 * 
 * Author           : Alexander J. Yee
 * Date Created     : 09/06/2016
 * Last Modified    : 09/23/2016
 * 
 */

#pragma once
#ifndef ymp_Memory_SmartBuffer_H
#define ymp_Memory_SmartBuffer_H
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Dependencies
#include <memory>
#include "AlignedMalloc.h"
namespace ymp{
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
template <typename T>
struct SmartBufferDeleter{
    void operator()(T* ptr) const{
        AlignedFree(ptr);
    }
};
template <typename T>
using SmartBuffer = std::unique_ptr<T, SmartBufferDeleter<T>>;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Typeless Buffer
template <upL_t alignment = DEFAULT_ALIGNMENT>
SmartBuffer<void> make_raw_buffer(upL_t bytes){
    void* ptr = AlignedMalloc(bytes, alignment);
    return SmartBuffer<void>(ptr);
}
////////////////////////////////////////////////////////////////////////////////
//  Typed Array
template <typename T, upL_t alignment = alignof(T)>
SmartBuffer<T> make_trivial_array(upL_t size){
    static_assert(
        std::is_trivially_constructible<T>::value,
        "Object must be trivially constructible."
    );
    static_assert(
        std::is_trivially_destructible<T>::value,
        "Object must be trivially destructible."
    );
    T* ptr = (T*)AlignedMalloc(size * sizeof(T), alignment);
//    for (upL_t c = 0; c < size; c++){
//        ::new (ptr + c) T();
//    }
    return SmartBuffer<T>(ptr);
}
////////////////////////////////////////////////////////////////////////////////
//  Object with user-specified size.
template <typename T, upL_t alignment = alignof(T), class... Args>
SmartBuffer<T> make_raw_object_buffer(upL_t bytes, Args&&... args){
    static_assert(
        std::is_trivially_destructible<T>::value,
        "Object must be trivially destructible."
    );
    T* ptr = (T*)AlignedMalloc(bytes, alignment);
    ::new (ptr) T(std::forward<Args>(args)...);
    return SmartBuffer<T>(ptr);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
}
#endif
