/* RawFile.h
 * 
 * Author           : Alexander J. Yee
 * Date Created     : 03/19/2018
 * Last Modified    : 03/24/2018
 * 
 *      Raw (unbuffered) I/O wrappers and helper classes.
 * 
 *  All reads and writes must be aligned to "RAWIO_ALIGNMENT" which is assumed
 *  to be large enough to handle any sector size.
 * 
 */

#pragma once
#ifndef ymp_FileIO_RawFile_H
#define ymp_FileIO_RawFile_H
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Dependencies
#include "PublicLibs/BasicLibs/Memory/SmartBuffer.h"
#if _WIN32
#include "RawFile_Windows.h"
#else
#include "RawFile_Linux.h"
#endif
namespace ymp{
namespace FileIO{
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
const upL_t RAWIO_ALIGNMENT = 4096;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
class RawIoBuffer{
public:
    RawIoBuffer(void* buffer, upL_t bytes);

    const void* buffer() const  { return m_buffer; }
    void*       buffer()        { return m_buffer; }
    upL_t       bytes() const   { return m_bytes; }

private:
    void* m_buffer;
    upL_t m_bytes;
};
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
class BufferedReader{
public:
    BufferedReader(RawFile& file);

    const std::string& path() const;
    ufL_t offset() const;

    char next(){
        if (m_buffer_offset == m_buffer_end){
            refill();
        }
        return m_buffer[m_buffer_offset++];
    }

private:
    void refill();

private:
//    alignas(RAWIO_ALIGNMENT) char m_buffer[RAWIO_ALIGNMENT];
    SmartBuffer<char> m_buffer;
    upL_t m_buffer_offset;
    upL_t m_buffer_end;
    ufL_t m_file_offset;
    FileIO::RawFile& m_file;
};
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
class BufferedWriter{
public:
    BufferedWriter(RawFile& file);
    ~BufferedWriter();

    const std::string& path() const;
    ufL_t offset() const;

    void push(char ch){
        if (m_buffer_offset == RAWIO_ALIGNMENT){
            refill();
        }
        m_buffer[m_buffer_offset++] = ch;
    }
    void push(const char* buffer, upL_t bytes);

private:
    void flush();
    void refill();

private:
    SmartBuffer<char> m_buffer;
    upL_t m_buffer_offset;
    ufL_t m_file_offset;
    FileIO::RawFile& m_file;
};
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
}
}
#endif
