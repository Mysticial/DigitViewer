/* TextWriter.cpp
 * 
 * Author           : Alexander J. Yee
 * Date Created     : 07/26/2013
 * Last Modified    : 07/26/2013
 * 
 */

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Dependencies
#include "PublicLibs/Exception.h"
#include "DigitViewer/Globals.h"
#include "DigitViewer/DigitConverter/DigitConverter.h"
#include "DigitViewer/DigitReaders/TextReader.h"
#include "TextWriter.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
namespace DigitViewer{
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//  Constructors
TextWriter::TextWriter(
    const std::string& path,
    const std::string& first_digits,
    bool raw,
    int radix
)
    : m_radix(radix)
    , m_file(0, path)
    , fp_convert(NULL)
{
    //  Write the first digits.
    if (first_digits.size() != 0){
        upL_t decimal_offset = first_digits.find('.');
        if (decimal_offset == std::string::npos)
            throw ym_exception("No decimal place was found.", YCR_DIO_ERROR_INVALID_PARAMETERS);
        m_file.write(first_digits.c_str(), decimal_offset + 1);
    }

    if (raw){
        switch (radix){
            case 10:
                fp_convert = raw_to_dec;
                break;
            case 16:
                fp_convert = raw_to_hex;
                break;
            default:
                throw ym_exception("Unsupported Radix", YCR_DIO_ERROR_INVALID_BASE);
        }
    }
}
TextWriter::~TextWriter(){
    flush_buffer();
}
std::unique_ptr<DigitReader> TextWriter::close_and_get_reader(upL_t buffer_size){
    if (m_iter_b_offset != 0){
        write(m_buffer, m_iter_b_offset);
        m_iter_b_offset = 0;
    }
    std::string path = m_file.GetPath();
    m_file.close();
    return std::make_unique<TextReader>(path, false, m_radix);
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void TextWriter::write(char* str, upL_t digits){
    //  If the buffer isn't empty and "str" isn't the buffer itself, then we
    //  must flush the buffer first.
    if (m_iter_b_offset != 0 && str != m_buffer){
        make_or_flush_buffer();
    }

    //  If the input isn't raw, convert it.
    if (fp_convert != nullptr){
        fp_convert(str, digits);
    }

    //  Write to disk.
    if (m_file.write(str, digits) != digits){
        FileIO::PrintLastError();
        throw ym_exception(
            "Error writing to file.\n" + m_file.GetPath(),
            FileIO::GetLastErrorCode()
        );
    }
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
}
